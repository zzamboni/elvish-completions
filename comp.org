#+title: Completion framework for Elvish
#+author: Diego Zamboni
#+email: diego@zzamboni.org

#+name: module-summary
A framework to easily define  [[https://elvish.io/ref/edit.html#completion-api][argument completers]] in Elvish. Used to implement most other modules in this repository. For a getting-started tutorial, see http://zzamboni.org/post/using-and-writing-completions-in-elvish/.

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]], to make it easy to explain. See [[file:comp.elv][comp.elv]] for the generated file.

* Table of Contents                                          :TOC_3:noexport:
- [[#usage][Usage]]
  - [[#completion-definitions][Completion definitions]]
    - [[#items][Items]]
    - [[#sequences-and-command-line-options][Sequences and command-line options]]
    - [[#subcommands][Subcommands]]
  - [[#utility-functions][Utility functions]]
- [[#implementation][Implementation]]
  - [[#utility-functions-1][Utility functions]]
    - [[#compdecorate][comp:decorate]]
    - [[#compempty][comp:empty]]
    - [[#compfiles-and-compdirs][comp:files and comp:dirs]]
    - [[#compextract-opts][comp:extract-opts]]
    - [[#comp-handler-arity][comp:-handler-arity]]
  - [[#completion-functions][Completion functions]]
    - [[#comp-expand-item][comp:-expand-item]]
    - [[#comp-expand-sequence][comp:-expand-sequence]]
    - [[#comp-expand-subcommands][comp:-expand-subcommands]]
  - [[#completion-wrapper-functions-main-entry-points][Completion wrapper functions (main entry points)]]
    - [[#compitem][comp:item]]
    - [[#compsequence][comp:sequence]]
    - [[#compsubcommands][comp:subcommands]]

* Usage

The =comp= module provides a few functions that make it easier to define completions in Elvish. Please note that this module is not intended for direct use in an Elvish session, but to write your own [[https://elvish.io/ref/edit.html#completion-api][argument completers]].

*NOTE: This module is very much in development, so the API, data structures, etc. may change at any moment.*

As a first step, install the =elvish-completions= package using [[https://elvish.io/ref/epm.html][epm]]:

#+begin_src elvish
  use epm
  epm:install github.com/zzamboni/elvish-completions
#+end_src

From the file where you will define your completions, load this module:

#+begin_src elvish
  use github.com/zzamboni/elvish-completions/comp
#+end_src

The main entry points for this module are =comp:item=, =comp:sequence= and =comp:subcommands=. Each one receives a single argument containing a  "completion definition", which indicates how the completions will be produced. Each one receives a different kind of completion structure, and returns a corresponding completion function, which receives the current contents of the command line (as passed to the [[https://elvish.io/ref/edit.html#argument-completer][argument completer functions]]) and returns the appropriate completions. The function returned by the =comp:*= functions can be assigned directly to an element of =$edit:completion:arg-completer=. A simple example:

#+begin_src elvish
  edit:completion:arg-completer[foo] = (comp:item [ bar baz ])
#+end_src

If you type this in your terminal, and then type =foo<space>= and press ~Tab~, you will see the appropriate completions:

#+begin_example
> foo <Tab>
 COMPLETING argument _
 bar  baz
#+end_example

To create completions for new commands, your main task is to define the corresponding completion definition. The different types of definitions and functions are explained below, with examples of the different available structures and features.

All three functions can also receive options =&pre-hook= and =&post-hook=. If specified, they must be lambdas which get executed before and after the completion is processed, respectively. Hooks cannot modify the result, and they should usually not be necessary, but you can use them for any maintenance or update tasks.
- =&pre-hook= must receive a single rest argument, and receives the current command line: =[@cmd]{ code }=
- =&post-hook= must receive an array and a rest argument, and receives the generated completions and the current command line: =[result @cmd]{ code }=

*Note:* the main entry points return a ready-to-use argument handler function. If you ever need to expand a completion definition directly (maybe for some advanced usage), you can call =comp:-expand-item=, =comp:-expand-sequence= and =comp:-expand-subcommands=, respectively. These functions all take the definition structure and the current command line, and return the appropriate completions at that point.

** Completion definitions
*** Items

The base building block is the "item", can be one of the following:

- An array containing all the potential completions (it can be empty, in which case no completions are provided). This is useful for providing a static list of completions.
- A function which returns the potential completions (it can return nothing, in which case no completions are provided). The function should have one of the following arities, which affect which arguments will be passed to it (other arities are not valid, and in that case the item will not be executed):
  - If it takes no arguments, no arguments are passed to it.
  - If it takes a single argument, it gets the current (last) component of the command line =@cmd=
  - If it takes a rest argument, it gets the full current command line (the contents of =@cmd=)

*Example #1:* a simple completer for =cd=

In this case, we define a function which receives the current "stem" (the part of the filename the user has typed so far) and offers all the relevant files, then filters those which are directories, and returns them as completion possibilities. We pass the function directly as a completion item to =comp:-expand=.

#+begin_src elvish
  fn complete-dirs [arg]{ put {$arg}* | each [x]{ if (-is-dir $x) { put $x } } }
  edit:completion:arg-completer[cd] = (comp:item $complete-dirs~)
#+end_src

I defined the =complete-dirs= function separately only for clarity - you can also embed the lambda directly as an argument to =comp:item=.

For file and directory completion, you can use the utility function =comp:files= instead of defining your own function (see [[*Utility functions][Utility functions]]):

#+begin_src elvish
  edit:completion:arg-completer[cd] = (comp:item [arg]{ comp:files $arg &dirs-only })
#+end_src

*** Sequences and command-line options

Completion items can be aggregated in a /sequence of items/ and used with the =comp:sequence= function when you need to provide different completions for different positional arguments of a command. Sequences include support for command-line options at the beginning of the command. The definition structure in this case has to be an array of items, which will be applied depending on their position within the command parameter sequence. If the the last element of the list is the string =...= (three periods), the next-to-last element of the list is repeated for all later arguments. If no completions should be provided past the last argument, simply omit the periods. If a sequence should produce no completions at all, you can use an empty list =[]=. If any specific elements of the sequence should have no completions, you can specify ={ comp:empty }= or =[]= as its value.

If the =&opts= option is passed to the =comp:sequence= function, it must contain a single definition item which produces a list of command-line options that are allowed at the beginning of the command, when no other arguments have been provided. Options can be specified in either of the following formats:
  - As a string which gets converted to a long-style option; e.g. =all= to specify the =--all= option. The string must not contain the dashes at the beginning.
  - As a map which may contain the following keys:
    - =short= for the short one-letter option;
    - =long= for the long-option string;
    - =desc= for a descriptive string which gets shown in the completion menu;
    - =arg-required= or =arg-optional=: either one but not both can be set to =$true= to indicate whether the option takes a mandatory or optional argument;
    - =arg-completer= can be specified and contain a completion item as described in [[*Items][Items]], and which will be expanded to provide completions for that argument's values.

Simple example of a completion data structure for option =-t= (long form =--type=), which has a mandatory argument which can be =elv=, =org= or =txt=:

#+begin_example
  [ &short=t
    &long=type
    &desc="Type of file to show"
    &arg-required=$true
    &arg-completer= [ elv org txt ]
  ]
#+end_example

*Note:* options are only offered as completions when the use has typed a dash as the first character. Otherwise the argument completers are used.

*Example #2:* we can improve on the previous completer for =cd= by preventing more than one argument from being completed (only the first argument will be completed using =complete-dirs=, since the list does not end with =...=):

#+begin_src elvish
  edit:completion:arg-completer[cd] = (comp:sequence [ [arg]{ comp:files $arg &dirs-only }])
#+end_src

*Example #3:* a simple completer for =ls= with a subset of its options. Note that =-l= and =-R= are only provided as completions when you have not typed any filenames yet. Also note that we are using [[*Utility functions][comp:decorate]] to display the files in a different color, and the =...= at the end of the sequence to use the same completer for all further elements.

#+begin_src elvish
  ls-opts = [
    [ &short=l                 &desc='use a long listing format' ]
    [ &short=R &long=recursive &desc='list subdirectories recursively' ]
  ]
  edit:completion:arg-completer[ls] = (comp:sequence &opts=$ls-opts \
    [ [arg]{ put $arg* | comp:decorate &style=blue } ... ]
  )
#+end_src

*Example #4:* See the [[https://github.com/zzamboni/elvish-completions/blob/master/ssh.org][ssh completer]] for a real-world example of using sequences.

*** Subcommands

Finally, completion sequences can be aggregated into /subcommand structures/ together with the =comp:subcommands= function, to provide completion for commands such as =git=, which accept multiple subcommands, each with their own options and completions. In this case, the definition is a map indexed by subcommand names. The value of each element can be a =comp:item=,  a =comp:sequence= or another =comp:subcommands= (to provide completion for sub-sub-commands, see the example below for =vagrant=). The =comp:subcommands= function can also receive option  =&opts= containing a single item definition to generate any available top-level options (to appear before the subcommand).

*Example #5:* a simple completer for the =brew= package manager, with support for the =install=, =uninstall= and =cat= commands. =install= and =cat= gets as completions all available packages (the output of the =brew search= command), while =uninstall= only completes installed packages (the output of =brew list=). Note that for =install= and =uninstall= we automatically extract command-line options from their help messages using the =comp:extract-opts= function, and pass them as the =&opts= option in the corresponding sequence functions. Also note that all =&opts= elements get initialized at definition time (they are arrays), whereas the sequence completions get evaluated at runtime (they are lambdas), to automatically update according to the current packages. The =cat= command sequence allows only one option. The load-time initialization of the options incurs a small delay, and you could replace these with lambdas as well so that the options are computed at runtime.

#+begin_src elvish
  brew-completions = [
    &install= (comp:sequence \
      &opts= [ (brew install -h | take 1 | comp:extract-opts &regex='()--(\w[\w-]*)()') ] \
      [ { brew search } ... ]
    )
    &uninstall= (comp:sequence \
      &opts= [ (brew uninstall -h | take 1 | comp:extract-opts &regex='()--(\w[\w-]*)()') ] \
      [ { brew list } ... ]
    )
    &cat= (comp:sequence [{ brew search }])
  ]

  edit:completion:arg-completer[brew] = (comp:subcommands &opts= [ version ] $brew-completions)
#+end_src

*Example #6:* a simple completer for a subset of =vagrant=, which receives commands which may have subcommands and options of their own. Note that the value of =&up= is a =comp:sequence=, but the value of =&box= is another =comp:subcommands= which includes the completions for =box add= and =box remove=. Also note the use of the =comp:extract-opts= function to extract the command-line arguments automatically from the help messages.

*Tip:* note that the values of =&opts= are functions (e.g. ={ vagrant-up -h | comp:extract-opts }=) instead of arrays (e.g. =( vagrant up -h | comp:extract-opts )=). As mentioned in Example #5, both would be valid, but in the latter case they are all initialized at load time (when the data structure is defined), which might introduce a delay (particularly with more command definitions). By using functions the options are only extracted at runtime when the completion is requested. For further optimization, =vagrant-opts= could be made to memoize the values so that the delay only occurs the first time.

#+begin_src elvish
  vagrant-completions = [
    &up= (comp:sequence [] \
      &opts= { vagrant up -h | comp:extract-opts }
    )
    &box= (comp:subcommands [
        &add= (comp:sequence [] \
          &opts= { vagrant box add -h | comp:extract-opts }
        )
        &remove= (comp:sequence [ { vagrant box list | eawk [_ @f]{ put $f[0] } } ... ] \
          &opts= { vagrant box remove -h | comp:extract-opts }
        )
  ])]

  edit:completion:arg-completer[vagrant] = (comp:subcommands &opts= [ version help ] $vagrant-completions)
#+end_src

*Example #7:* See the [[https://github.com/zzamboni/elvish-completions/blob/master/git.org][git completer]] for a real-world subcommand completion example, which also shows how extensively auto-population of subcommands and options can be done by extracting information from help messages.

** Utility functions

=comp:decorate= maps its input through =edit:complex-candidate= with the given options. Can be passed the same options as [[https://elvish.io/ref/edit.html#argument-completer][edit:complex-candidate]]. In addition, if =&suffix= is specified, it is used to set both =&display-suffix= and =&code-suffix=. Input can be given either as arguments or through the pipeline:

#+begin_src elvish
> comp:decorate &suffix=":" foo bar
▶ (edit:complex-candidate foo &code-suffix=: &display-suffix=: &style='')
▶ (edit:complex-candidate bar &code-suffix=: &display-suffix=: &style='')
> put foo bar | comp:decorate &style="red"
▶ (edit:complex-candidate foo &code-suffix='' &display-suffix='' &style=31)
▶ (edit:complex-candidate bar &code-suffix='' &display-suffix='' &style=31)
#+end_src

=comp:extract-opts= takes input from the pipeline and extracts command-line option data structures from its output. By default it understand the following common formats:

#+begin_example
  -o, --option                Option description
  -p, --print[=<what>]        Option with an optional argument
      --select <type>         Option with a mandatory argument
#+end_example

Typical use would be to populate an =&opts= element with something like this:

#+begin_src elvish
  comp:sequence &opts= { vagrant -h | comp:extract-opts } [ ... ]
#+end_src

The regular expression used to extract the options can be specified with the =&regex= option. Its default value is:

#+begin_src elvish :noweb-ref opt-capture-regex
    &regex='^\s*(?:-(\w),?\s*)?(?:--?([\w-]+))?(?:\[=(\S+)\]|[ =](\S+))?\s*?\s\s(\w.*)$'
#+end_src

The mapping of capture groups from the regex to option components is defined by the =&regex-map= option. Its default value (which also shows the available fields) is:

#+begin_src elvish :noweb-ref opt-capture-map
    &regex-map=[&short=1 &long=2 &arg-optional=3 &arg-requested=4 &desc=5]
#+end_src

At least one of =short= or =long= must be present in =regex-map=. The =arg-optional= and =arg-required= groups, if present, are handled specially: if any of them is not empty, then its contents is stored as =arg-desc= in the output, and the corresponding =arg-required= / =arg-optional= is set to =$true=.

If =&fold= is =$true=, then the input is preprocessed to join option descriptions which span more than one line (the heuristic is not perfect and may not work in all cases, also for now it only joins one line after the option).

*Example #8:* the =brew= completer shown before can be made to show package names in different styles (green when installing, red when uninstalling). Here we also show the use of =comp:extract-opts= with custom regex for capturing the options from the =brew= help messages:

#+begin_src elvish
  brew-completions = [
    &install= (comp:sequence \
      &opts= [(brew install -h | take 1 |
          comp:extract-opts &regex='--(\w[\w-]*)(?:=(.*?)\])?' &regex-map=[&long=1 &arg-required=2]
      )]  \
      [ { brew search | comp:decorate &style=green } ... ]
    )
    &uninstall= (comp:sequence \
      &opts= [(brew uninstall -h | take 1 |
          comp:extract-opts &regex='--(\w[\w-]*)' &regex-map=[&long=1]
      )] \
      [ { brew list | comp:decorate &style=red } ... ]
    )
    &cat= (comp:sequence [{ brew search }])
  ]

  edit:completion:arg-completer[brew] = (comp:subcommands &opts= [ version ] $brew-completions)
#+end_src

* Implementation
:PROPERTIES:
:header-args:elvish: :tangle (concat (file-name-sans-extension (buffer-file-name)) ".elv")
:header-args: :mkdirp yes :comments no
:END:

We start by loading some basic modules we need.

#+begin_src elvish
  use re
  use github.com/zzamboni/elvish-modules/util
#+end_src

** Utility functions

*** comp:decorate

=comp:decorate= maps its input through =edit:complex-candidate= with the given options. Can be passed the same options as [[https://elvish.io/ref/edit.html#argument-completer][edit:complex-candidate]]. In addition, if =&suffix= is specified, it is used to set both =&display-suffix= and =&code-suffix=.

#+begin_src elvish
  fn decorate [@input &code-suffix='' &display-suffix='' &suffix='' &style='']{
    if (eq (count $input) 0) {
      input = [(all)]
    }
    if (not-eq $suffix '') {
      display-suffix = $suffix
      code-suffix = $suffix
    }
    each [k]{
      edit:complex-candidate &code-suffix=$code-suffix &display-suffix=$display-suffix &style=$style $k
    } $input
  }
#+end_src

*** comp:empty

=comp:empty= produces no completions. It can be used to mark an item in a sequence that should not produce any completions.

#+begin_src elvish
  fn empty { nop }
#+end_src

*** comp:files and comp:dirs

=comp:files= completes filenames, using any typed prefix as the stem. If the =&regex= option is specified, only files matching that pattern are completed. If =&dirs-only= is =$true=, only directories are returned.

#+begin_src elvish
  fn files [arg &regex='' &dirs-only=$false]{
    edit:complete-filename $arg | each [c]{
      x = $c[stem]
      if (or (-is-dir $x) (and (not $dirs-only) (or (eq $regex '') (re:match $regex $x)))) {
        put $c
      }
    }
  }
#+end_src

=comp:dirs= is simply a convenience wrapper around =comp:files= which sets =&dirs-only= automatically.

#+begin_src elvish
  fn dirs [arg &regex='']{
    files $arg &regex=$regex &dirs-only=$true
  }
#+end_src

*** comp:extract-opts

=comp:extract-opts= takes input from the pipeline and parses it using a regular expression. The default regex contains 5 groups to parse the =short=, =long=, =arg-required=, =arg-optional= and =desc=, but both the regex and the mapping can be configured using the =&regex= and =&regex-map= options. At last one of short/long is mandatory, everything else is optional. Returns an option map with all existing keys, depending on the available groups and the keys in =$regex-map=. Only produces an output if at least =short= or =long= has a value. The =arg-optional= and =arg-required= groups, if present, are handled specially: if any of them is not empty, then its contents is stored as =arg-desc= in the output, and the corresponding =arg-required= / =arg-optional= is set to =$true=.

If =&fold= is =$true=, then the input is preprocessed to join option descriptions which span more than one line (the heuristic is not perfect and may not work in all cases, also for now it only joins one line after the option).

#+begin_src elvish :noweb yes
  fn extract-opts [@cmd
    <<opt-capture-regex>>
    <<opt-capture-map>>
    &fold=$false
  ]{
    -line = ''
    capture = $all~
    if $fold {
      capture = { each [l]{
          if (re:match '^\s+\w' $l) {
            put $-line$l
            -line = ''
          } else {
            put $-line
            -line = $l
          }
        }
      }
    }
    $capture | each [l]{ re:find $regex $l } | each [m]{
      g = $m[groups]
      opt = [&]
      keys $regex-map | each [k]{
        if (has-key $g $regex-map[$k]) {
          field = $g[$regex-map[$k]][text]
          if (not-eq $field '') {
            if (has-value [arg-optional arg-required] $k) {
              opt[$k] = $true
              opt[arg-desc] = $field
            } else {
              opt[$k] = $field
            }
          }
        }
      }
      if (or (has-key $opt short) (has-key $opt long)) {
        put $opt
      }
    }
  }
#+end_src

*** comp:-handler-arity

Determine the arity of a function and return a string representation, for internal use.

#+begin_src elvish
  fn -handler-arity [func]{
    fnargs = [ (count $func[arg-names]) (not-eq $func[rest-arg] '') ]
    if     (eq $fnargs [ 0 $false ]) { put no-args
    } elif (eq $fnargs [ 1 $false ]) { put one-arg
    } elif (eq $fnargs [ 0 $true  ]) { put rest-arg
    } else {                           put other-args
    }
  }
#+end_src

** Completion functions

The backend completion functions =comp:-expand-item=, =comp:-expand-sequence= and =comp:-expand-subcommands= are the ones that actually process the completion definitions and, according to them and the current command line, provide the available completions.

*** comp:-expand-item

=comp:-expand-item=  expands a "completion item" into its completion values. If it's a function, it gets executed with arguments corresponding to its arity; if it's a list, it's exploded to its elements.

#+begin_src elvish
  fn -expand-item [def @cmd]{
    arg = $cmd[-1]
    what = (kind-of $def)
    if (eq $what 'fn') {
      [ &no-args=  { $def }
        &one-arg=  { $def $arg }
        &rest-arg= { $def $@cmd }
        &other-args= { put '<completion-fn-arity-error>' }
      ][(-handler-arity $def)]
    } elif (eq $what 'list') {
      explode $def
    } else {
      echo (styled "comp:-expand-item: invalid item of type "$what": "(to-string $def) red) >/dev/tty
    }
  }
#+end_src

*** comp:-expand-sequence

=comp:-expand-sequence= receives an array of definition items and the current contents of the command line, and uses =edit:complete-getopt= to actually generate the completions. For this, we need to make sure the options and argument handler data structures are in accordance to what =edit:complete-getopt= expects.

#+begin_src elvish
  fn -expand-sequence [seq @cmd &opts=[]]{
#+end_src

We first preprocess the options. If =&opts= is provided, it has to be a completion item which expands to a list with one element per option. Elements that are maps are assumed to be in getopt format (with keys =short=, =long=, =desc=, =arg-required=, =arg-optional= and =arg-desc=) and used as-is (their structure is not checked). Elements which are strings are considered as long option names and converted to the appropriate data structure.

#+begin_src elvish
  final-opts = [(
      -expand-item $opts $@cmd | each [opt]{
        if (eq (kind-of $opt) map) {
          put $opt
        } else {
          put [&long= $opt]
        }
      }
  )]
#+end_src

To allow specifying completers for option arguments, we check if the previous component of the command line is an existing option. If so, and if the option structure has an =arg-completer= key, then it is expanded as a completion item and offered as completions. If the option definition has the =arg-required= key, then no other completions are offered, otherwise the code falls through to the argument handlers, which means the completions for the first argument handler would also be produced.

#+begin_src elvish
  fn -has-and-is [def opt]{
    or (and (has-key $def short) (eq '-'$def[short] $opt)) (and (has-key $def long) (eq '--'$def[long] $opt))
  }

  if (>= (count $cmd) 3) {
    prev-opt = [&]
    prev-word = $cmd[-2]
    each [o]{
      if (-has-and-is $o $prev-word) {
        prev-opt = $o
      }
    } $final-opts
    if (and (not-eq $prev-opt [&]) (has-key $prev-opt arg-completer)) {
      -expand-item $prev-opt[arg-completer] $@cmd
      if (and (has-key $prev-opt arg-required) $prev-opt[arg-required]) {
        return
      }
    }
  }
#+end_src


We also preprocess the handlers. =edit:complete-getopt= expects each handler to receive only one argument (the current word in the command line), but =comp= allows handlers to receive no arguments, one argument (the current element of the command line) or multiple arguments (the whole command line), so we need to normalize them. Happily, Elvish's functional nature makes this easy by checking the arity of each handler and, if necessary, wrapping them in one-argument functions, but passing them the information they expect. We also wrap items which are arrays into corresponding functions. As a special case, the string ='...'= is also passed, as it is allowed by =edit:complete-getopt= to indicate that the last element needs to be repeated for future elements. Any other handlers are ignored.

#+begin_src elvish
  final-handlers = [(
      explode $seq | each [f]{
        if (eq (kind-of $f) 'fn') {
          put [
            &no-args=  [_]{ $f }
            &one-arg=  $f
            &rest-arg= [_]{ $f $@cmd }
            &other-args= [_]{ put '<completion-fn-arity-error>' }
          ][(-handler-arity $f)]
        } elif (eq (kind-of $f) 'list') {
          put [_]{ explode $f }
        } elif (and (eq (kind-of $f) 'string') (eq $f '...')) {
          put $f
        }
      }
  )]
#+end_src

Finally, we call =edit:complete-getopt= with the corresponding data structures. It expects the current line /without/ the initial command, so we remove that as well.

#+begin_src elvish
    edit:complete-getopt $cmd[1:] $final-opts $final-handlers
  }
#+end_src

*** comp:-expand-subcommands

=comp:-expand-subcommands= receives a definition map and the current contents of the command line.

#+begin_src elvish
  fn -expand-subcommands [def @cmd &opts=[]]{
#+end_src

The algorithm for =comp:-expand-subcommands= is a bit counterintuitive, this is how it works:

1. Scan the current command to see if a valid subcommand is found (i.e. an element which matches an existing key in =$def=).
  #+begin_src elvish
      subcommands = [(keys $def)]
      n = (count $cmd)
      kw = [(range 1 $n | each [i]{
            if (has-value $subcommands $cmd[$i]) { put $cmd[$i] $i }
      })]
  #+end_src

2. If a subcommand is found, call its expansion function directly, and with the command line at that position. We check if the definition is a string, in which case it's expected to be the name of some other command whose definition we need to use (to implement command aliases) - we substitute the alias for its target command and call =-expand-subcommands= with the new values.
  #+begin_src elvish
      if (and (not-eq $kw []) (not-eq $kw[1] (- $n 1))) {
        sc sc-pos = $kw[0 1]
        if (eq (kind-of $def[$sc]) 'string') {
          cmd[$sc-pos] = $def[$sc]
          -expand-subcommands &opts=$opts $def $@cmd
        } else {
          $def[$sc] (explode $cmd[{$sc-pos}:])
        }
  #+end_src

3. If no subcommand is found, generate a sequence definition which returns the subcommand names for the first position (including any provided options).
  #+begin_src elvish
      } else {
        top-def = [ { put $@subcommands } ]
        -expand-sequence &opts=$opts $top-def $@cmd
      }
    }
  #+end_src

This seems backwards from what one (or at least I) initially expected - I attempted at first multiple variations to expand the subcommands/top-options first, and then only expand the subcommand options and definition from the "tail" handlers, but this doesn't work because of the way =edit:complete-getops= works, the top-level options would get expanded for subcommands as well. This way, we catch the more specific case first (subcommand definition) and only if there's no subcommand in the command line yet, we do the top-level expansion. All with simple and clear code (you wouldn't believe some of the variations I tried while trying to get this to work!).

** Completion wrapper functions (main entry points)

The wrapper functions =comp:item=, =comp:sequence= and =comp:subcommands= are the main entry points - they receive the completion definitions and call the corresponding =-expand-*= function. They also take care of running the pre- and post-hooks, if specified.

*** comp:item

#+begin_src elvish
  fn item [item &pre-hook=$nop~ &post-hook=$nop~]{
    put [@cmd]{
      $pre-hook $@cmd
      result = [(-expand-item $item $@cmd)]
      $post-hook $result $@cmd
      put $@result
    }
  }
#+end_src

*** comp:sequence

#+begin_src elvish
  fn sequence [sequence &opts=[] &pre-hook=$nop~ &post-hook=$nop~]{
    put [@cmd]{
      $pre-hook $@cmd
      result = [(-expand-sequence &opts=$opts $sequence $@cmd)]
      $post-hook $result $@cmd
      put $@result
    }
  }
#+end_src

*** comp:subcommands

#+begin_src elvish
  fn subcommands [def &opts=[] &pre-hook=$nop~ &post-hook=$nop~]{
    put [@cmd]{
      $pre-hook $@cmd
      result = [(-expand-subcommands &opts=$opts $def $@cmd)]
      $post-hook $result $@cmd
      put $@result
    }
  }
#+end_src
